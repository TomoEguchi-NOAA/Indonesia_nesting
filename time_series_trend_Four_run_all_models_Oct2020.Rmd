
---
title: "Combining data imputation and trend analysis using discrete Fourier series"
output: html_notebook
---

Trying to merge the data imputation process and trend analysis with multiple datasets.

Model names were changed to streamline file names. Also added modified versions of models. In the new models (v2), the middle "state" space (x) is eliminated. Nt is modeled as a random variable, then Nt is divided into each month (X but not treated as a random variable), then y is observed from each X.

Set things up:

```{r}
rm(list=ls())

# tic <- Sys.time()
# Sys <- Sys.info()
source('Dc_Indonesia_nesting_fcns.R')
#library(rjags)

library(jagsUI)
library(coda)
library(tidyverse)
library(loo)
```


```{r}
save.data <- T
save.fig <- T
run.date <- "2020-10-14" #Sys.Date() #"2019-06-25" #

year.begin <- 2002
year.end <- 2019

period.JM <- 12
period.W <- 6
maxN <- 10000

UQ.models <- c("1U_1Q", 
               "1U_2Q",
               "2U_1Q",
               "2U_2Q")

# t_loc has location (or series) specific df parameter 
state.models <- c("norm", "t")
obs.models <- c("norm", "t") # 
v.models <- c("DFS_v1", "DFS_v2")  # v2 models have no Xs - Ns are the state

```


Set up the MCMC parameters

```{r}
MCMC.n.chains <- 5
MCMC.n.samples <- 50000
MCMC.n.burnin <- 10000
MCMC.n.thin <- 5

MCMC.params <- list(n.chains = MCMC.n.chains,
                    n.samples = MCMC.n.samples,
                    n.burnin = MCMC.n.burnin,
                    n.thin = MCMC.n.thin)
```


Bring in the data

```{r}

data.jags.JM <- data.extract(location = "JM", 
                             year.begin = year.begin, 
                             year.end = year.end)

# Begining year for Wermon is 2002.
data.jags.W <- data.extract(location = "W", 
                             year.begin = year.begin, 
                             year.end = year.end)

```

Get warnings but they are harmless - I think. 

Combine datasets for analysis

```{r}
y <- array(data= NA, dim = c(nrow(data.jags.JM$jags.data2$y),
                             ncol(data.jags.JM$jags.data2$y), 2))
y[,,1] <- data.jags.JM$jags.data2$y
y[,,2] <- data.jags.W$jags.data2$y

jags.data <- list(y = y,
                  #m = data.jags.JM$jags.data2$m,
                  C0 = c(15, 15),
                  n.months = 12,
                  C_cos = c(sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) cos(2 * pi * x/period.JM))), 
                            sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) cos(2 * pi * x/period.W)))),
                  C_sin = c(sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) sin(2 * pi * x/period.JM))),
                            sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) sin(2 * pi * x/period.W)))),
                  pi = pi,
                  period = c(period.JM, period.W),
                  N0_mean = c(log(sum(exp(y[1,,1]), na.rm = T)),
                              log(sum(exp(y[1,,2]), na.rm = T))),
                  N0_sd = c(10, 10),
                  n.states = 2)

#n.timeseries <- dim(y)[3]

#jags.data$n.timeseries <- n.timeseries
jags.data$n.years <- dim(y)[1]

# jags.data$q_alpha <- 2
# jags.data$q_beta <- 0.5
# jags.data$r_alpha <- 2
# jags.data$r_beta <- 0.5

```

run jags on each model
```{r}
c <- 1
loo.out <- list()
filenames <- list()
k1 <- k2 <- 1
for (k1 in 1:length(UQ.models) ){ #3:()
  UQ.model <- UQ.models[k1]
  for (k2 in 1:length(obs.models)){
    obs.model <- obs.models[k2]
    for (k3 in 1:length(state.models)){
      state.model <- state.models[k3]
      for (k4 in 1:length(v.models)){
        v.model <- v.models[k4]
        filename.root <- paste0("SSAR1_", state.model, "_", 
                                obs.model, "_trend_", 
                                v.model, "_",
                                UQ.model, "_",
                                "JM", period.JM, 
                                "_W", period.W, "_",
                                year.begin, "_", 
                                year.end, "_", run.date)
        
        filenames[[c]] <- filename.root
        # define parameters to monitor - add "df" for t distribution
        jags.params <- c('N', 'U', "p", "p.beta.cos", "p.beta.sin",
                         "sigma.Q", "sigma.R", 
                         "mu", "y", "deviance", "loglik")
        
        if (v.model == "DFS_v1"){
          jags.params <- c(jags.params, "X")
        }
        
        if (obs.model == "t"){
          jags.params <- c(jags.params, "df.y")
        }
        
        if (state.model == "t"){
          jags.params <- c(jags.params, "df.X")
        }
        
        model.name <- paste0("models/trend_models/model_", 
                             state.model, "_", obs.model, 
                             "_trend_", v.model, "_", 
                             UQ.model, ".txt")
        
        if (file.exists(model.name)){
          
          print(paste0("Running: ", model.name))
          
          if (!file.exists(paste0("RData/", filename.root, '.rds'))){
            jm <- jags(jags.data,
                       inits = NULL,
                       parameters.to.save= jags.params,
                       model.file = model.name,
                       n.chains = MCMC.params$n.chains,
                       n.burnin = MCMC.params$n.burnin,
                       n.thin = MCMC.params$n.thin,
                       n.iter = MCMC.params$n.samples,
                       DIC = T, parallel=T)
            
            saveRDS(jm,
                    file = paste0("RData/", filename.root, '.rds'))
          } else {
            jm <- readRDS(file = paste0("RData/", filename.root, '.rds'))
          }
          
          if (!file.exists(paste0("RData/", filename.root, "_loo.rds"))){
            loo.out[[c]] <- compute.LOOIC(loglik = jm$sims.list$loglik, 
                                          MCMC.params = MCMC.params, 
                                          data.vector = as.vector(jags.data$y))
            saveRDS(loo.out[[c]], file = paste0("RData/", filename.root, "_loo.rds"))
          } else {
            loo.out[[c]] <- readRDS(file = paste0("RData/", filename.root, "_loo.rds"))
            
          }
          
          c <- c + 1
          
        } else {
          print(paste0("Model file ", model.name, " does not exist" ))
        }    
        
      }
      
    }
    
  }
}

```

First look at the Pareto k diagnostics first to see how the models fit.

```{r}
pareto.k <- lapply(loo.out, 
                   FUN = function(x) x$loo.out)

# find maximum pareto k values

max.pareto.k <- unlist(lapply(pareto.k,
       FUN = function(x) max(x$diagnostics$pareto_k)))

# find the models that have max(pareto k) < 0.7
good.models <- filenames[which(max.pareto.k < 0.7)]

```


Compare the results using LOOIC:

```{r}
looic.esimates <- lapply(lapply(loo.out[which(max.pareto.k < 0.7)], 
                                FUN = function(x) x$loo.out),
                         FUN = function(x) x$estimates)

looic <- unlist(lapply(looic.esimates, 
                       FUN = function(x) x["looic", "Estimate"]))

best.model <- good.models[which(looic == min(looic))]
```

START HERE. 2020-10-14

According to the LOOIC values, normal process and t observation models with independent slope and variance terms was considered best. 

Take a look at all data points vs. pareto k

```{r}

data.jags.JM$data.1 %>% select(Frac.Year, Nests, Season) %>%
  mutate(Loc = "JM") %>%
  # transmute(Frac.Year = Frac.Year,
  #           Nests.JM = Nests,
  #           Season = Season) %>% 
  na.omit() -> data.JM

data.jags.W$data.1 %>% select(Frac.Year, Nests, Season) %>%
  mutate(Loc = "W") %>%
  # transmute(Frac.Year = Frac.Year, 
  #           Nests.W = Nests) %>%
  na.omit() -> data.W

data.loo <- rbind(data.JM, data.W)
# n.JM <- nrow(data.JM)
# n.both <- n.JM + nrow(data.W)
data.loo$pareto.k <- pareto.k.best$diagnostics$pareto_k

ggplot(data = data.loo) + 
  geom_point(aes(x = Frac.Year, y = pareto.k, color = Loc))
```

Pareto k values are worse for the Wermon dataset than for the JM dataset. I wonder if two separate models need to be fit for the two datasets... 


```{r}
# Look at another model (model 1)
jags.out <- readRDS(file = paste0("RData/", best.model[[1]], ".rds"))
jm <- jags.out$jm

bayesplot::mcmc_dens(jm$samples, c("U"))
```

```{r}
data.frame(jm$summary) %>% rownames_to_column("Parameter") -> summary.df

#summary.df[grep(summary.df$Parameter, pattern = "U\\["),]
summary.df[grep(summary.df$Parameter, pattern = "U"),]
```


```{r}
bayesplot::mcmc_dens(jm$samples, c("sigma.Q[1]", "sigma.Q[2]"))
```

Looks a bit suspicious...

```{r}
bayesplot::mcmc_trace(jm$samples, c("sigma.Q[1]", "sigma.Q[2]"))
```

See site-specific analyses next. 


