---
title: "Combining data imputation and trend analysis using discrete Fourier series using stan"
output: html_notebook
---

Trying to merge the data imputation process and trend analysis with multiple datasets. This version uses stan instead of jags to see if my code for extracting loglikelihood is correct and to move to using stan. In this analysis I first use simulated data to compare results with jags output. 

Set things up:

```{r}
rm(list=ls())

library(rstan)
library(rstanarm)
library(loo)
library(tidyverse)

save.data <- T
save.fig <- F
run.date <- Sys.Date()

```

Set up the plotting colors.
```{r}

fill.color <-  "darkseagreen"
fill.color.N1 <- "blue4"
fill.color.N2 <- "gold4"
fill.color.summer <- "darksalmon"
fill.color.winter <- "gray65"
fill.alpha <-  0.65
line.color <-  "darkblue"
line.color.N <- "cadetblue"
line.color.summer <- "red3"
line.color.winter <- "greenyellow"
data.color <- "black"
data.size <- 1.5
obsd.color <- "red2"

```



Set up the MCMC parameters

```{r}
MCMC.n.chains <- 5
MCMC.n.samples <- 500000
MCMC.n.burnin <- 350000
MCMC.n.thin <- 50

MCMC.params <- list(n.chains = MCMC.n.chains,
                    n.samples = MCMC.n.samples,
                    n.burnin = MCMC.n.burnin,
                    n.thin = MCMC.n.thin)
```


Bring in the data

```{r}
out.list <- readRDS("RData/sim_constCV_independentUQ_data_parameters_2019-07-08.rds")

data.1 <- out.list$data %>% select(year, month, y.1.norm) %>% 
  mutate(Frac.Year = year + (month-0.5)/12,
         nests = y.1.norm) %>%
  select(-y.1.norm)

data.2 <- out.list$data %>% select(year, month, y.2.norm) %>% 
  mutate(Frac.Year = year + (month-0.5)/12,
         nests = y.2.norm) %>%
  select(-y.2.norm)

# add some missing data:
n.NA <- 20
data.1$nests[sample(1:length(data.1$nests), n.NA, replace = FALSE)] <- NA
data.2$nests[sample(1:length(data.2$nests), n.NA, replace = FALSE)] <- NA

y.1 <- matrix(data.1$nests, ncol = 12, byrow = TRUE)
y.2 <- matrix(data.2$nests, ncol = 12, byrow = TRUE)

m <- matrix(out.list$data$month, 
            ncol = 12, byrow = TRUE)

year.begin <- min(out.list$data$year)
year.end <- max(out.list$data$year)

period.1 <- 12
period.2 <- 6
```

Combine datasets for analysis

```{r}
y <- array(data= NA, 
           dim = c(nrow(y.1),
                   ncol(y.1), 2))
y[,,1] <- y.1
y[,,2] <- y.2

data.list <- list(y = y,
                  m = m,
                  C0 = c(15, 15),
                  n.months = 12,
                  C_cos = c(sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) cos(2 * pi * x/period.1))), 
                            sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) cos(2 * pi * x/period.2)))),
                  C_sin = c(sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) sin(2 * pi * x/period.1))),
                            sum(apply(matrix(1:12, nrow=1), 
                                      MARGIN = 1, 
                                      FUN = function(x) sin(2 * pi * x/period.2)))),
                  pi = pi,
                  period = c(period.1, period.2),
                  N0_mean = c(log(sum(exp(y[1,,1]), na.rm = T)),
                              log(sum(exp(y[1,,2]), na.rm = T))),
                  N0_sd = c(10, 10),
                  n.states = dim(y)[3],
                  n.years = dim(y)[1])

```

Define which parameters to monitor

```{r}
jags.params <- c('N', 'U', "p", "p.beta.cos", "p.beta.sin",
                 "sigma.N", 'sigma.Q', "sigma.R",
                 "mu", "y", "X", "deviance", "loglik")

```


Run stan

```{r}
mod_q_phi <- stan("models/model_norm_norm_trend_Four_monthQ_independentUQs.stan", 
                 data = data_list, 
                 chains = MCMC.n.chains, 
                 warmup = MCMC.n.burnin,
                 iter = MCMC.n.samples,
                 cores = getOption("mc.cores", 5),
                 control = list(adapt_delta = 0.99))
```


pull together results
```{r}
# extract ys - include estimated missing data
# these need to be arranged in vectors
ys.stats.JM <- data.frame(low = as.vector(t(jm$q2.5$y[,,1])),
                          median = as.vector(t(jm$q50$y[,,1])),
                          high = as.vector(t(jm$q97.5$y[,,1])))
ys.stats.JM$time <- data.jags.JM$data.1$Frac.Year
ys.stats.JM$obsY <- data.jags.JM$data.1$Nests
ys.stats.JM$month <- data.jags.JM$data.1$Month
ys.stats.JM$year <- data.jags.JM$data.1$Year
ys.stats.JM$Season <- data.jags.JM$data.1$Season
ys.stats.JM$location <- "Jamursba-Medi"

ys.stats.W <- data.frame(low = as.vector(t(jm$q2.5$y[,,2])),
                         median = as.vector(t(jm$q50$y[,,2])),
                         high = as.vector(t(jm$q97.5$y[,,2])))
ys.stats.W$time <- data.jags.W$data.1$Frac.Year
ys.stats.W$obsY <- data.jags.W$data.1$Nests
ys.stats.W$month <- data.jags.W$data.1$Month
ys.stats.W$year <- data.jags.W$data.1$Year
ys.stats.W$Season <- data.jags.W$data.1$Season
ys.stats.W$location <- "Wermon"

ys.stats <- rbind(ys.stats.JM, ys.stats.W)

# extract Xs - the state model

Xs.stats.JM <- data.frame(low = as.vector(t(jm$q2.5$X[,,1])),
                          median = as.vector(t(jm$q50$X[,,1])),
                          high = as.vector(t(jm$q97.5$X[,,1])))
Xs.stats.JM$time <- data.jags.JM$data.1$Frac.Year
Xs.stats.JM$obsY <- data.jags.JM$data.1$Nests
Xs.stats.JM$month <- data.jags.JM$data.1$Month
Xs.stats.JM$year <- data.jags.JM$data.1$Year
Xs.stats.JM$Season <- data.jags.JM$data.1$Season
Xs.stats.JM$location <- "Jamursba-Medi"

Xs.stats.W <- data.frame(low = as.vector(t(jm$q2.5$X[,,2])),
                         median = as.vector(t(jm$q50$X[,,2])),
                         high = as.vector(t(jm$q97.5$X[,,2])))
Xs.stats.W$location <- "Wermon"

Xs.stats.W$time <- data.jags.W$data.1$Frac.Year
Xs.stats.W$obsY <- data.jags.W$data.1$Nests
Xs.stats.W$month <- data.jags.W$data.1$Month
Xs.stats.W$year <- data.jags.W$data.1$Year
Xs.stats.W$Season <- data.jags.W$data.1$Season

Xs.stats <- rbind(Xs.stats.JM, Xs.stats.W)

Ns.stats.JM <- data.frame(time = year.begin:year.end,
                          low = as.vector(t(jm$q2.5$N[1,])),
                          median = as.vector(t(jm$q50$N[1,])),
                          high = as.vector(t(jm$q97.5$N[1,])))
Ns.stats.JM$location <- "Jamursba-Medi"

Ns.stats.W <- data.frame(time = year.begin:year.end,
                         low = as.vector(t(jm$q2.5$N[2,])),
                         median = as.vector(t(jm$q50$N[2,])),
                         high = as.vector(t(jm$q97.5$N[2,])))
Ns.stats.W$location <- "Wermon"

Ns.stats <- rbind(Ns.stats.JM, Ns.stats.W)
```


I'm not sure how to extract log likelihood and properly compute loo statistics. Need to investigate this more. 

```{r}
# 
# ####
# n.per.chain <- (MCMC.params$n.samples - MCMC.params$n.burnin)/MCMC.params$n.thin
#   
#   # reduce the dimension by MCMC iterations by year x month
#   loglik.JM <- t(apply(jm$sims.list$loglik[,,,1], 
#                     MARGIN = 1, 
#                     FUN = function(x) as.vector(t(x))))
#   
#   loglik.W <- t(apply(jm$sims.list$loglik[,,,2], 
#                     MARGIN = 1, 
#                     FUN = function(x) as.vector(t(x))))
#   
#   #loglik <- cbind(loglik.JM, loglik.W)
#   # convert the data (y) into a vector also:
#   y.JM <- as.vector(t(jags.data$y[,,1]))
#   y.W <- as.vector(t(jags.data$y[,,2]))
#   
#   loglik.obs.JM <- loglik.JM[, !is.na(y.JM)]
#   loglik.obs.W <- loglik.W[, !is.na(y.W)]
#   
#   # get rid of NA columns - even if data existed (for example the first value) - no likelihood
#   # for the first data point
#   loglik.obs.JM <- loglik.obs.JM[, colSums(is.na(loglik.obs.JM)) == 0]
#   loglik.obs.W <- loglik.obs.W[, colSums(is.na(loglik.obs.W)) == 0]
#   
#   loglik.obs <- cbind(loglik.obs.JM, loglik.obs.W)
#   # cores = 1 is needed in the relative_eff function if the number of cores was set to more than
#   # 1 with options(mc.cores = parallel::detectCores()) or something similear. See also here:
#   # https://discourse.mc-stan.org/t/error-in-loo-relative-eff-related-to-options-mc-cores/5610/2
#   
#   Reff <- relative_eff(exp(loglik.obs), 
#                        chain_id = rep(1:MCMC.params$n.chains, 
#                                       each = n.per.chain),
#                        cores = 1)
#   
#   loo.out <- loo(loglik.obs, r_eff = Reff, cores = 1)
#   ####
# loo.out <- pareto.k.diag.3D(jm, MCMC.params, jags.data)


```


plot model fit statistics - pareto k
```{r}

# pareto.k <- loo.out$loo.out$diagnostics$pareto_k
# data.y <- na.omit(data.jags$jags.data$y)
# 
# pareto.df <- data.frame(y = data.y,
#                         khat = pareto.k,
#                         datapoint = seq(from = 1, to = length(data.y)),
#                         k0.7 = cut(pareto.k,
#                                    breaks = c(0, 0.7, 1.5),
#                                    labels = c("<=0.7", ">0.7")))
# p.2 <- ggplot(data = pareto.df) +   
#   geom_path(aes(x = datapoint, y = exp(y)), alpha = 0.5) +
#   geom_point(aes(x = datapoint, y = exp(y), 
#                  size = khat,
#                  color = k0.7)) +
#   scale_size_continuous(limits = c(0.0, 1.3),
#                         range = c(1, 4))+ 
#   scale_color_manual(values = c("<=0.7" = "black", 
#                                 ">0.7" = "red")) 

```


Save results if needed

```{r}
results.all <- list(jm = jm,
                    Xs.stats = Xs.stats,
                    ys.stats = ys.stats,
                    Ns.stats = Ns.stats)
if (save.data)
  saveRDS(results.all,
          file = paste0("RData/", filename.root, '.rds'))
```


Look at some posteriors
```{r}
# pop growth rates - over the entire time
# bayesplot::mcmc_trace(jm$samples, c("U[1]", "U[2]"))
# 
# bayesplot::mcmc_trace(jm$samples, "p.beta.cos[1]")

bayesplot::mcmc_dens(jm$samples, c("U[1]", "U[2]"))
bayesplot::mcmc_dens(jm$samples, c("sigma.Q[1]", "sigma.Q[2]"))

# cos and sin for the discrete Foureir series 
bayesplot::mcmc_dens(jm$samples, c("p.beta.cos[1]", "p.beta.sin[1]",
                                   "p.beta.cos[2]", "p.beta.sin[2]"))

bayesplot::mcmc_dens(jm$samples, "sigma.N")

```


Make some plots (need to change colors... )

```{r}
# p.1 <- ggplot() +
#   geom_ribbon(data = Xs.stats,
#               aes(x = time, 
#                   ymin = exp(low_X), 
#                   ymax = exp(high_X),
#                   color = location),
#               alpha = fill.alpha) +
#   geom_point(data = Xs.stats,
#              aes(x = time, 
#                  y = exp(median_X_JM)), 
#              color = line.color,
#              alpha = 0.5) +
#   geom_line(data = Xs.stats,
#             aes(x = time, 
#                 y = exp(median_X_JM)), 
#             color = line.color,
#             alpha = 0.5) +
#   geom_point(data = ys.stats,
#              aes(x = time, y = obsY_JM), 
#              color = obsd.color,
#              alpha = 0.5) + 
#   geom_ribbon(data = Ns.stats,
#               aes(x = time, 
#                   ymin = exp(low_N_JM),
#                   ymax = exp(high_N_JM)),
#               fill = fill.color.N,
#               alpha = fill.alpha) + 
#   geom_line(data = Ns.stats,
#             aes(x = time, y = exp(median_N_JM)),
#             color = line.color.N,
#             alpha = 0.5,
#             size = 1.5) + 
#   scale_x_continuous(breaks = seq(year.begin, year.end, 5),
#                      limits = c(year.begin, year.end)) +
#   scale_y_continuous(limits = c(0, maxN)) + 
#   labs(x = '', y = '# nests')  +
#   theme(axis.text = element_text(size = 12),
#         text = element_text(size = 12))

#p.1
p.1a <- ggplot() +
  geom_ribbon(data = Xs.stats,
              aes(x = time, 
                  ymin = low, 
                  ymax = high),
              fill = fill.color,
              alpha = fill.alpha) + 
  geom_point(data = Xs.stats,
             aes(x = time, 
                 y = median),
             color = data.color,
             alpha = 0.5) +
  geom_line(data = Xs.stats,
            aes(x = time, 
                y = median),
            color = line.color,
            alpha = 0.5) +
  geom_point(data = ys.stats,
             aes(x = time, 
                 y = log(obsY)),
             color = obsd.color,
             alpha = 0.5) + 
  geom_ribbon(data = Ns.stats,
              aes(x = time, 
                  ymin = low,
                  ymax = high),
              color = fill.color.N1,
              alpha = fill.alpha) + 
  geom_line(data = Ns.stats,
            aes(x = time, y = median),
            color = line.color.N,
            alpha = 0.5,
            size = 1.5) + 
  scale_x_continuous(breaks = seq(year.begin, year.end, 5),
                     limits = c(year.begin, year.end)) +
  scale_y_continuous(limits = c(0, log(maxN))) + 
  facet_grid(rows = vars(location)) + 
  labs(x = '', y = 'log(# nests)')  +
  theme(axis.text = element_text(size = 12),
        text = element_text(size = 12))

p.1a



```


save plots if requested

```{r}
if (save.fig){
  # ggsave(filename = paste0("figures/", filename.root, ".png"),
  #        plot = p.1,
  #        dpi = 600,
  #        device = "png")
  
  ggsave(filename = paste0("figures/", filename.root, ".png"),
         plot = p.1a,
         dpi = 600,
         device = "png")

  # ggsave(filename = paste0("figures/", filename.root,  "_pareto.png"),
  #      plot = p.2,
  #      dpi = 600,
  #      device = "png")
  
}

```

