# simple state space AR1 model for turtle nesting 
# original code from Lab 7, Introduction to Bayesian Time-Series
# analysis using Jags. Univ Washington: 
# https://www.scribd.com/document/373707632/Lab-7-Fitting-models-with-JAGS-pdf

# Also can be found here:
# https://nwfsc-timeseries.github.io/atsa-labs/sec-jags-uss.html
#
# For this model, the natural log of raw counts were used as data (y). The state model
# is Student's t and the observation model is norm. The probability of nesting in a month
# is modeled with a discrete Fourier series - p[month] sums to 1.0 over each 12 month period.
# To normalize the monthly probability (i.e., they have to sum to 1.0 over 12 months), each
# monthly value has to be divided by the sum.  Constant parts (sum(cos(2*pi*m/P)) and sum(sin(2*pi*m/P),
# where sum is over all m (months) and P is period (6 months for Wermon and 12 months for JM)),
# need to be supplied as data as C_cos and C_sin. Also, C0 is a constant to make all Fourier 
# series values to be > 0.  I think C0 >= 2 should do... (not really... 10 did the trick)
#
# I used quite informative prior for X[1] ~ dnorm(5, 0.1) although variance of 10 should 
# be wide enough in the log scale.  I used similar priors for the slopes: dnorm(0, 0.1).
# For all standard deviations (process and observation), I used uniform between 0 and 20, 
# which should be wide enough in the log scale. 
#
# I didn't see any reason to make the priors flatter because that would make convergence difficult
# and did not gain anything in return. 

model{
    # for single U model, there is one state but two time series.
    # Initial states
           
     for(i in 1:n.timeseries) {
            
        N0[i] ~ dnorm(N0_mean[i], 1/(N0_sd[i]^2))    # prior on init state
        predN[i,1] <- N0[i] + U  
        N[i,1] <- predN[i,1]

    }	
    #N0 ~ dnorm(N0_mean, 1/(N0_sd^2))    # prior on init state
    #predN[j,1] <- N0[j] + U  
    #N[1] ~ dnorm(N0 + U, tau.N) 
  
    for (j in 1:n.timeseries){
        for (t in 1:n.months){
            # m[j,t] is the same for all rows so change array to a vector?
            #predX[1,t,j] <- log(p[j, m[1,t]]) + N[j,1]
            predX[1,t,j] <- log(p[j, t]) + N[j,1]
            X[1,t,j] ~ dt(predX[1,t,j], tau.Q, df_X[j])

            # observation
            # By having the total abundance N in the model, I don't think this inproduct
            # calculation is needed. The dependency between the timeseries, or lack thereof,
            # is modeled by the new parameters U (one for single and two for independent)
            #predY[1,t,j] <- inprod(Z[j, 1:n.states], X[1,t,j])
            y[1,t,j] ~  dnorm(X[1,t,j], tau.R[j])
                
            loglik[1,t,j] <- logdensity.norm(y[1,t,j], X[1,t,j], tau.R[j])
        }       
    }

    ####  End of initial states ####
    
    for (s in 2:n.years){            

        for (j in 1:n.timeseries){
           #N[j,s] ~ dnorm(pred.N[j, s], tau.N)
           #pred.N[j, s] <- U + N[j, s-1]
           N[j, s] <- U + N[j, s-1]

            for (t in 1:n.months){
                # N is in the log space but p is not. 
                predX[s,t,j] <- log(p[j, t]) + N[j,s]
                X[s,t,j] ~ dt(predX[s,t,j], tau.Q, df_X[j])

                # observation
                # By having the total abundance N in the model, I don't think this inproduct
                # calculation is needed. The dependency between the timeseries, or lack thereof,
                # is modeled by the new parameters U (one for single and two for independent)
                #predY[s,t,j] <- inprod(Z[j, 1:n.states], X[s,t,j])
                y[s,t,j] ~  dnorm(X[s,t,j], tau.R[j])
                
                loglik[s,t,j] <- logdensity.norm(y[s,t,j], X[s,t,j], tau.R[j])
            }       

        }

    }

    # monthly proportions for distributing N into 12 months are modeled discrete Fourier series with a given
    # period
    # n.months = 12 when entire year is modeled. 
    # n.months = 6 when one season is modeled (Wermon only)
    for (j in 1:n.timeseries){
        for (k in 1:n.months){
            p.const[j, k] <-  2 * pi * k / period[j]
            p[j, k] <- (C0[j] + p.beta.cos[j] * cos(p.const[j,k]) + p.beta.sin[j] * sin(p.const[j,k]))/(n.months * C0[j] + p.beta.cos[j] * C_cos[j] + p.beta.sin[j] * C_sin[j])
        }
        sigma.R[j] ~ dgamma(2, 0.5)
        tau.R[j] <- 1/(sigma.R[j] * sigma.R[j])
        p.beta.cos[j] ~ dnorm(0, 1)
        p.beta.sin[j] ~ dnorm(0, 1)
        df_X[j] ~ dgamma(5, 0.1)T(2,) 

    }

    U ~ dnorm(u_mean, 1/(u_sd^2))
    
    # Q is the variance of the process (X)
    sigma.Q ~ dgamma(2, 0.5)
    tau.Q <- 1/(sigma.Q * sigma.Q)    
                          
    sigma.N ~ dgamma(2, 0.5)
    tau.N <- 1/(sigma.N * sigma.N)

    u_mean <- 0
    u_sd <- 1 
    
}
